#include "WorkbookScopeFunctions.h"
#include "Connect.h"
#include "ComVariant.h"
#include <xlOil-Dynamic/LocalFunctions.h>
#include <xlOil/Range.h>
#include <xlOil/Register.h>
#include <xlOilHelpers/Environment.h>
#include <xloil/FuncSpec.h>
#include <xloil/ExcelCall.h>
#include <xloil/State.h>
#include <xlOil/ExcelTypeLib.h>
#include <xlOil/ExcelThread.h>
#include <xlOil/AppObjects.h>
#include <vector>
#include <memory>

using std::vector;
using std::shared_ptr;
using std::wstring;
using std::wstring_view;
using namespace VBIDE;

namespace xloil
{
  namespace COM
  {
    namespace
    {
      bool checkRegistryKeys()
      {
        auto excelVersion = Environment::excelProcess().version;
        auto regKey = fmt::format(L"Software\\Microsoft\\Office\\{0}.0\\Excel\\Security\\AccessVBOM", excelVersion);
        DWORD currentUser = 666, localMachine = 666;
        getWindowsRegistryValue(L"HKCU", regKey.c_str(), currentUser);
        getWindowsRegistryValue(L"HKLM", regKey.c_str(), localMachine);
        if (currentUser == 0 || localMachine == 0)
          XLO_THROW("Allow access to VBA Object Model in "
            "File > Options > Trust Center > Trust Center Settings > Macro Settings");
        return true;
      }
      constexpr char* oldAutoGenModuleName = "xlOil_AutoGenerated";
    }

    struct Writer
    {
      int line;
      VBIDE::_CodeModulePtr mod;

      template <typename S, typename... Args>
      void write(const S& fmtStr, Args&&... args)
      {
        mod->InsertLines(line++, fmt::format(fmtStr, std::forward<Args>(args)...).c_str());
      }

      /// <summary>
      /// Write a line which is save to auto-break at spaces. Such a line should
      /// not contain strings which may contain spaces. The line length limit
      /// in VBA is 1024 chars.
      /// </summary>
      template <typename S, typename... Args>
      void writeBreakable(const S& fmtStr, Args&&... args)
      {
        wstring text = fmt::format(fmtStr, std::forward<Args>(args)...);
        while (text.length() > 1000)
        {
          auto lastSpace = wstring_view(text.data(), 1000).find_last_of(L' ');
          mod->InsertLines(line++, (wstring(text.data(), lastSpace + 1) + L'_').c_str());
          text.erase(0, lastSpace + 1);
        }
        mod->InsertLines(line++, text.c_str());
      }
    };

    void writeLocalFunctionsToVBA(
      const wchar_t* workbookName,
      const vector<shared_ptr<const LocalWorksheetFunc>>& registeredFuncs,
      const wchar_t* vbaModuleName,
      const bool append)
    {
      try
      {
        // Check we have trusted access to VBA object model
        static bool registryChecked = checkRegistryKeys();

        auto workbook = thisApp().workbooks().get(workbookName);

        VBIDE::_VBProjectPtr vbProj;
        try
        {
          vbProj = workbook.com().VBProject;
        }
        catch (const _com_error& e)
        {
          if (e.Error() == 0x800A03EC) // Name not found
            XLO_THROW("Could not get VBProject object: allow access to the VBA Object Model in "
              "Excel > File > Options > Trust Center > Trust Center Settings > Macro Settings");
          throw;
        }

        struct _VBComponent* vbFound = 0;
        if (SUCCEEDED(vbProj->VBComponents->raw_Item(_variant_t(oldAutoGenModuleName), &vbFound)))
          vbProj->VBComponents->Remove(vbFound);

        _VBComponentPtr vbMod;
        auto startLine = 1;
        if (SUCCEEDED(vbProj->VBComponents->raw_Item(_variant_t(vbaModuleName), &vbFound)))
        {
          vbMod = vbProj->VBComponents->Item(vbaModuleName);
          if (!append)
            vbMod->CodeModule->DeleteLines(1, vbMod->CodeModule->CountOfLines);
          else
            startLine = vbMod->CodeModule->CountOfLines + 1;
        }
        else
        {
          vbMod = vbProj->VBComponents->Add(vbext_ct_StdModule);
          vbMod->PutName(vbaModuleName);
        }

        Writer writer{ startLine, vbMod->CodeModule };
        if (startLine == 1)
          writer.write(L"Declare PtrSafe Function localFunctionEntryPoint "
            "Lib \"xloil.dll\" "
            "(ByRef funcId as LongPtr, "
            " ByRef ret as variant, "
            " ByRef args as variant) as Long");

        for (size_t i = 0; i < registeredFuncs.size(); ++i)
        {
          auto& func = *registeredFuncs[i]->info();

          if (func.args.size() > XL_MAX_VBA_FUNCTION_ARGS)
            XLO_THROW("Local functions may have at most 60 arguements due to VBA limitations");

          // We declare all args as optional variant and let the called 
          // function handle things.
          wstring args, optionalArgs;
          for (auto& arg : func.args)
          {
            args += arg.name + L',';
            optionalArgs += L"Optional " + arg.name + L",";
          }

          // Drop final comma
          if (!optionalArgs.empty()) optionalArgs.pop_back();
          if (!args.empty()) args.pop_back();

          // We write:
          // 
          // Public Function name(Optional arg0, Optional arg1,...)
          //   Dim args: args = Array(arg0, arg1, ...)
          //   localFunctionEntryPoint workbook, 'name, name, args
          // End Function
          // 
          // For a command we replace Function with Sub and add a dummy return
          // as localFunctionEntryPoint expects a return value
          //
          const bool isSub = (func.options & FuncInfo::COMMAND) != 0;
          const auto& name = func.name;
          const auto funcType = isSub ? L"Sub" : L"Function";
          const auto retVar = isSub ? L"dummy" : name;
          const auto funcId = registeredFuncs[i]->registerId();

          writer.writeBreakable(L"Public {2} {0}({1})", name, optionalArgs, funcType);
          writer.writeBreakable(L"  Dim xlo_args: xlo_args=Array({0})", args);
          if (isSub)
            writer.write(L"  Dim dummy");
          writer.write(L"  localFunctionEntryPoint {0}, {1}, xlo_args",
            funcId, retVar);
          writer.write(L"End {0}", funcType);
        }
      }
      XLO_RETHROW_COM_ERROR;
    }
  }
}
